# Auto-generated by composer.py
# Base algorithm: AES
# Rounds: 10
from typing import Any, List

# Selected components (fully qualified names preserved in docstrings)
from src.Components import aes_key_expansion  # AES/key_schedule
from src.Components import inv_sub_bytes  # AES/sub_bytes
from src.Components import shift_rows  # AES/shift_rows
from src.Components import inv_mix_columns  # AES/mix_columns
from src.Components import add_round_key  # AES/add_round_key
from src.Components import inv_shift_rows  # Inverse component

def encrypt_block(plaintext: bytes, key: bytes) -> bytes:
    """Composed encryption function.
    Base=AES; Stages=key_schedule, sub_bytes, shift_rows, mix_columns, add_round_key; Components=aes_key_expansion, inv_sub_bytes, shift_rows, inv_mix_columns, add_round_key
    """
    # Convert bytes to appropriate format for components
    state = list(plaintext)  # AES/Serpent components work with List[int]
    # key schedule
    round_keys = aes_key_expansion(key)
    for r in range(10):
        state = inv_sub_bytes(state)
        state = shift_rows(state)
        state = inv_mix_columns(state)
        state = add_round_key(state, round_keys[r])

    # Convert back to bytes
    return bytes(state)

def decrypt_block(ciphertext: bytes, key: bytes) -> bytes:
    """Decryption using inverse components in reverse order."""
    # Convert bytes to appropriate format for components
    state = list(ciphertext)  # AES/Serpent components work with List[int]
    # key schedule
    round_keys = aes_key_expansion(key)
    
    # Decrypt: reverse rounds, inverse operations
    for r in range(10 - 1, -1, -1):
        state = add_round_key(state, round_keys[r])
        state = inv_mix_columns(state)
        state = inv_shift_rows(state)
        state = inv_sub_bytes(state)
    
    # Convert back to bytes
    return bytes(state)

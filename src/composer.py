# src/composer.py
import os
import re
import textwrap
import importlib.util
import tempfile
from typing import Dict
from .schemas import CompositionRequest, CompositionResult, AlgorithmSpec
from .component_registry import find_component_by_name, scan_components

GENERATED_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "data", "generated_algorithms")
os.makedirs(GENERATED_DIR, exist_ok=True)

_TEMPLATE = """# Auto-generated by composer.py
# Base algorithm: {base}
# Rounds: {rounds}
from typing import Any, List

# Selected components (fully qualified names preserved in docstrings)
{component_imports}

def encrypt_block(plaintext: bytes, key: bytes) -> bytes:
    \"\"\"Composed encryption function.
    Base={base}; Stages={stages}; Components={component_names}
    \"\"\"
    # Convert bytes to appropriate format for components
    {state_init}
    # key schedule
    round_keys = {key_schedule}(key)
{round_loop}
    # Convert back to bytes
    {state_return}

def decrypt_block(ciphertext: bytes, key: bytes) -> bytes:
    \"\"\"Naive inverse by replaying in reverse when possible. You can replace with true inverse if available.\"\"\"
    # NOTE: For full correctness you may need inverse components; validator tests round-trip with generated adapters.
    # This function simply calls encrypt again for placeholder; you can refine per component capabilities.
    # TODO: Implement real inverse stages if available.
    return encrypt_block(ciphertext, key)
"""

def _build_round_loop(structure: str, rounds: int, selections: Dict[str, str]) -> str:
    if structure.upper() == "FEISTEL":
        rf = selections.get("round_function")
        line = (
            "    left = state[:len(state)//2]\n"
            "    right = state[len(state)//2:]\n"
            "    for r in range({rounds}):\n"
            "        fout = {rf}(right, round_keys[r])\n"
            "        left, right = right, bytes(a ^ b for a,b in zip(left, fout))\n"
            "    state = right + left\n"
        ).format(rounds=rounds, rf=rf)
        return line
    # default SPN-like
    sb = selections.get("sub_bytes")
    sr = selections.get("shift_rows")
    mc = selections.get("mix_columns")
    ark = selections.get("add_round_key")
    body = []
    body.append("    for r in range({}):".format(rounds))
    if sb:  body.append(f"        state = {sb}(state)")
    if sr:  body.append(f"        state = {sr}(state)")
    if mc:  body.append(f"        state = {mc}(state)")
    if ark: body.append(f"        state = {ark}(state, round_keys[r])")
    return "\n".join(body) + "\n"

def _find_inverse_components(selected_components: Dict[str, str]) -> Dict[str, str]:
    """Find inverse components for the selected components.
    Returns a dict mapping stage -> inverse_component_name
    """
    # Scan all available components
    all_components = scan_components()
    
    inverse_map = {}
    
    # Common inverse naming patterns
    inverse_patterns = {
        'sub_bytes': 'inv_sub_bytes',
        'shift_rows': 'inv_shift_rows',
        'mix_columns': 'inv_mix_columns',
    }
    
    for stage, comp_name in selected_components.items():
        # Check if this component has a known inverse
        if stage in inverse_patterns:
            inv_name = inverse_patterns[stage]
            # Check if the inverse exists in any algorithm
            for alg, comps in all_components.items():
                for comp in comps:
                    if comp.name == inv_name:
                        inverse_map[stage] = inv_name
                        break
    
    return inverse_map

def _build_decrypt_spn(blueprint: AlgorithmSpec, 
                       selected_components: Dict[str, str],
                       inverse_map: Dict[str, str],
                       rounds: int,
                       state_init: str,
                       state_return: str) -> str:
    """Build a proper decrypt function for SPN structure using inverse components."""
    
    key_schedule = selected_components.get('key_schedule', 'aes_key_expansion')
    
    # For AES-like SPN, decryption is: reverse round order, inverse operations
    decrypt_lines = []
    decrypt_lines.append("def decrypt_block(ciphertext: bytes, key: bytes) -> bytes:")
    decrypt_lines.append('    """Decryption using inverse components in reverse order."""')
    decrypt_lines.append(f"    # Convert bytes to appropriate format for components")
    decrypt_lines.append(f"    state = list(ciphertext)  # AES/Serpent components work with List[int]")
    decrypt_lines.append(f"    # key schedule")
    decrypt_lines.append(f"    round_keys = {key_schedule}(key)")
    decrypt_lines.append(f"    ")
    decrypt_lines.append(f"    # Decrypt: reverse rounds, inverse operations")
    decrypt_lines.append(f"    for r in range({rounds} - 1, -1, -1):")
    
    # Apply inverse operations in reverse order of encryption
    # Encryption order: sub_bytes -> shift_rows -> mix_columns -> add_round_key
    # Decryption order: inv_add_round_key -> inv_mix_columns -> inv_shift_rows -> inv_sub_bytes
    
    # add_round_key is its own inverse
    if 'add_round_key' in selected_components:
        decrypt_lines.append(f"        state = {selected_components['add_round_key']}(state, round_keys[r])")
    
    # Use inverse for mix_columns
    if 'mix_columns' in inverse_map:
        decrypt_lines.append(f"        state = {inverse_map['mix_columns']}(state)")
    elif 'mix_columns' in selected_components:
        # No inverse available, try to use forward (won't work correctly)
        decrypt_lines.append(f"        state = {selected_components['mix_columns']}(state)  # WARNING: No inverse found!")
    
    # Use inverse for shift_rows
    if 'shift_rows' in inverse_map:
        decrypt_lines.append(f"        state = {inverse_map['shift_rows']}(state)")
    elif 'shift_rows' in selected_components:
        decrypt_lines.append(f"        state = {selected_components['shift_rows']}(state)  # WARNING: No inverse found!")
    
    # Use inverse for sub_bytes
    if 'sub_bytes' in inverse_map:
        decrypt_lines.append(f"        state = {inverse_map['sub_bytes']}(state)")
    elif 'sub_bytes' in selected_components:
        decrypt_lines.append(f"        state = {selected_components['sub_bytes']}(state)  # WARNING: No inverse found!")
    
    decrypt_lines.append(f"    ")
    decrypt_lines.append(f"    # Convert back to bytes")
    decrypt_lines.append(f"    return bytes(state)")
    
    return "\n".join(decrypt_lines)

def compose(blueprint: AlgorithmSpec, req: CompositionRequest) -> CompositionResult:
    # validate component existence
    missing = []
    comp_imports = []
    components_info = []
    selected_components = {}  # stage -> component name
    
    for stage in blueprint.stages:
        chosen = req.selections.get(stage.name)
        if not chosen and stage.required:
            missing.append(stage.name)
        elif chosen:
            comp = find_component_by_name(chosen)
            if comp is None:
                missing.append(f"{stage.name} (component '{chosen}' not found)")
            else:
                mod_name = comp.fn_ref.__module__
                comp_imports.append(f"from {mod_name} import {comp.name}  # {comp.algorithm}/{stage.name}")
                components_info.append((comp.algorithm, comp.name, stage.name))
                selected_components[stage.name] = comp.name
    if missing:
        return CompositionResult(False, "", "", errors=[f"Missing selections: {', '.join(missing)}"])

    # Detect data type based on components used
    # AES, Serpent, and similar use List[int]
    # DES, Blowfish, and similar use int
    uses_list_int = any(alg in ["AES", "SERPENT", "RC6"] for alg, _, _ in components_info)
    
    if uses_list_int:
        state_init = "state = list(plaintext)  # AES/Serpent components work with List[int]"
        state_return = "return bytes(state)"
    else:
        state_init = "state = plaintext"
        state_return = "return state"
    
    # Try to find inverse components for decryption
    inverse_map = _find_inverse_components(selected_components)
    has_inverses = len(inverse_map) > 0
    
    # Generate initial code from template
    code = _TEMPLATE.format(
        base=req.base_algorithm,
        rounds=req.extra_rounds or blueprint.rounds,
        component_imports="\n".join(comp_imports),
        stages=", ".join(s.name for s in blueprint.stages),
        component_names=", ".join(req.selections.get(s.name,"-") for s in blueprint.stages),
        key_schedule=req.selections.get("key_schedule", "lambda k:[k]*{}".format(req.extra_rounds or blueprint.rounds)),
        round_loop=_build_round_loop(blueprint.structure, req.extra_rounds or blueprint.rounds, req.selections),
        state_init=state_init,
        state_return=state_return,
    )
    
    # Add inverse component imports if needed
    if has_inverses:
        inverse_imports = []
        for inv_name in inverse_map.values():
            if inv_name and f"import {inv_name}" not in code:
                inv_comp = find_component_by_name(inv_name)
                if inv_comp:
                    mod_name = inv_comp.fn_ref.__module__
                    inverse_imports.append(f"from {mod_name} import {inv_name}  # Inverse component")
        if inverse_imports:
            # Add after existing imports
            import_section_end = code.find('\ndef encrypt_block')
            code = code[:import_section_end] + "\n".join(inverse_imports) + "\n" + code[import_section_end:]
    
    # Build proper decrypt function if we have inverses
    if has_inverses and blueprint.structure.upper() == "SPN":
        decrypt_impl = _build_decrypt_spn(blueprint, selected_components, inverse_map, 
                                          req.extra_rounds or blueprint.rounds, state_init, state_return)
        # Replace the placeholder decrypt_block function
        decrypt_pattern = r'def decrypt_block\(ciphertext: bytes, key: bytes\) -> bytes:.*?(?=\n(?:def |$)|\Z)'
        code = re.sub(decrypt_pattern, decrypt_impl, code, flags=re.DOTALL)

    file_name = f"{req.output_name}.py"
    path = os.path.join(GENERATED_DIR, file_name)
    with open(path, "w", encoding="utf-8") as f:
        f.write(code)

    return CompositionResult(True, code, path, info={"generated_path": path})

def load_generated_module(module_path: str):
    spec = importlib.util.spec_from_file_location("generated_cipher", module_path)
    mod = importlib.util.module_from_spec(spec)
    assert spec and spec.loader
    spec.loader.exec_module(mod)  # type: ignore
    return mod
